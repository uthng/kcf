#!/usr/bin/env bash
[[ -n $DEBUG ]] && set -x

set -eou pipefail

readonly SCRIPT_NAME="$(basename "$0")"
readonly FZF_OPTS=${FZF_OPTS:-"--ansi --no-preview"}
readonly -a SUPPORTED_CMD=("exec" "log" "logs" "describe" "delete")
readonly -a SUPPORTED_CMD_CONTAINER=("exec" "log" "logs")

# Print usage or help of this script
function print_usage {
    cat <<EOF
    ${SCRIPT_NAME} wraps certain kubectl commands with fzf. It means that it allows you to select a resource corresponding to the specified type and perform the given command on it.

    ${SCRIPT_NAME} uses the same commands, resource types and options as kubectl.

    Usage: ${SCRIPT_NAME} <CMD> <TYPE> <OPTION1>...<OPTIONX>

    CMD:       exec, log(s), describe and delete.
    TYPE:      all kubectl resource types supported by the above commands.
    OPTIONS:   all kubectl options normally used with the above commands & types.

    Examples:
    - Describe a pod in a given namespace:
      kcf describe pod -n istio-system

    - Execute a command shell in a container within a pod:
      kcf exec pod -n dsf-offer-catalog-orchestrator -- ls -la

    - Execute a interactive shell in a container within a pod:
      kcf exec pod -n dsf-offer-catalog-orchestrator -it -- bash

    - Watch logs of a container within a pod in a given namespace:
      kcf logs pod -n istio-system -f
EOF
}

# Print log message with level and corresponding color
# Params:
#   $1: level
#   $2: message
# Return
#   string log message with date, level, program and color
#
# Examples:
#   log "INFO" "This is INFO level"
#   Returns: N/A
function log {
    local readonly level="$1"
    local readonly message="$2"
    local readonly timestamp=$(date +"%Y-%m-%d %H:%M:%S")
    local color=""
    local reset_color="$(tput sgr0)"

    if [[ "${level}" == "INFO" ]]; then
        color="$(tput setaf 2)"
    elif [[ "${level}" == "WARN" ]]; then
        color="$(tput setaf 3)"
    elif [[ "${level}" == "ERROR" ]]; then
        color="$(tput setaf 1)"
    fi

    >&2 echo -e "${color}${timestamp} [${level}] [$SCRIPT_NAME] ${message}${reset_color}"
}

# Print INFO log message
# Params:
#   $1: message
# Return
#   string log message with level INFO
#
# Examples:
#   log_info This is INFO level"
#   Returns: N/A
function log_info {
    local readonly message="$1"
    log "INFO" "$message"
}

# Print WARN log message
# Params:
#   $1: message
# Return
#   string log message with level WARN
#
# Examples:
#   log_warn This is WARN level"
#   Returns: N/A
function log_warn {
    local readonly message="$1"
    log "WARN" "$message"
}

# Print ERROR log message
# Params:
#   $1: message
# Return
#   string log message with level ERROR
#
# Examples:
#   log_error This is ERROR level"
#   Returns: N/A
function log_error {
    local readonly message="$1"
    log "ERROR" "$message"
}

# Assert non empty with exit
# Params:
#   $1: name
#   $2: value
# Return
#   N/A
#
# Examples:
#   assert_not_empty "--base-datadir" "${base_datadir}"
#   Returns: N/A
function assert_not_empty {
    local readonly arg_name="$1"
    local readonly arg_value="$2"

    if [[ -z "$arg_value" ]]; then
        log_error "The value for '$arg_name' cannot be empty"
        print_usage
        exit 1
    fi
}

# Assert error with messsage and exit
# Params:
#   $1: returned value
#   $2: message error
# Return
#   N/A
#
# Examples:
#   assert_error "$ret" "Message error"
#   Returns: N/A
function assert_error {
    local readonly ret=$1
    local readonly msg="$2"

    if [ ${ret} -ne 0 ]
    then
        if [ "${msg}" != "" ]
        then
            log_err "${msg}"
        fi
        exit 1
    fi
}

# Check if an item is in the array
# Params:
#   $1: item
#   $2: array
# Return
#   1 if yes, 0 otherwise
#
# Examples:
#   array_contains "B" ("A", "B", "C")
#   Returns: 1
function array_contains {
    local -r item="$1"
    shift
    local -ra arr=("$@")

    local it
    for it in "${arr[@]}"; do
        if [[ "$it" == "$item" ]]; then
            return 0
        fi
    done

    return 1
}

# Split a string to an array
# Params:
#   $1: separator
#   $2: string
# Return
#   an array
#
# Examples:
#   array_split "," "A,B,C"
#   Returns: ("A" "B" "C")
function array_split {
    local -r separator="$1"
    local -r str="$2"
    local -a arr=()

    IFS="$separator" read -a arr <<<"$str"

    echo ${arr[*]}
}

# Remove multiple spaces between words of a string
# Params:
#   $1: string
# Return
#   string
#
# Examples:
#   str_remove_multiple_spaces "aa     bb   cc"
#   Returns: "aa bb cc"
function str_remove_multiple_spaces {
    local -r str="$1"

    echo -e "${str}" | sed 's/  */ /g'
}

# Get a list of containers within a pod
# Params:
#   $1: pod name
#   $2: options compatible with command `kubectl get pod`
# Return
#   string containing containers with separator newline "\n"
#
# Examples:
#   _kcf_get_pod_containers "grafana-5f68d98f87-hvmbb" "-n istio-system"
#   Returns: "grafana\nistio-proxy"
function _kcf_get_pod_containers {
    local -r podname="$1"
    local -r opts="$2"

    local str_opts=`str_remove_multiple_spaces "get pod/${podname} ${opts} -o jsonpath='{.spec.containers[*].name}'"`

    log_info "kubectl ${str_opts}"

    # Dont know why there are quote un the returned string.
    # So need to remove them and replace space by newline \n
    # to show correctly the list with fzf
    kubectl ${str_opts} | sed "s/\'//g" | tr " " "\n"
}

# Parse options and execute kubectl commands
function _kcf_cmd {
    local readonly cmd="$1"
    local readonly type="$2"
    shift 2

    local ns=""
    local get_opts=""
    local cmd_opts=""
    local args=""

    while [[ $# > 0 ]]; do
        local key="$1"

        case "$key" in
            -n|--namespace)
                get_opts="${get_opts} -n $2"
                cmd_opts="${cmd_opts} -n $2"
                shift 2
                ;;
            --)
                args="${args} $@"
                shift $#
                ;;
            *)
                cmd_opts="${cmd_opts} ${key}"
                shift
                ;;
            esac
        done

    # Check cmd
    if ! array_contains "${cmd}" "${SUPPORTED_CMD[@]}"; then
        log_error "${cmd} not supported"
        return 1
    fi

    local resources=$(kubectl get ${type} --no-headers ${get_opts})

    # Split string containing all resources to array with '\n' as delimiter
    local SAVEIFS=${IFS}
    local IFS=$'\n'
    local readonly arr_resources=($resources)
    IFS=${SAVEIFS}

    if [[ ${#arr_resources[@]} -gt 0 ]]; then
        #echo "${resources}" | fzf | awk '{print $1}' | xargs -o -I % kubectl ${cmd} ${type}/% ${ns} ${args}
        resource=$(echo "${resources}" | fzf ${FZF_OPTS} --header="Select a resource:" | awk '{print $1}')

        # Clean spaces in case of namespace not specified
        local str_opts=$(str_remove_multiple_spaces "${cmd} ${type}/${resource} ${cmd_opts}")
        # Check if cmd needs to specify container
        if array_contains "${cmd}" "${SUPPORTED_CMD_CONTAINER[@]}"; then
            # Must store the result into an intermediare variable because of
            # log_info in the function _kcf_get_pod_containers
            local containers=$(_kcf_get_pod_containers "${resource}" "${get_opts}")
            local container=$(echo "${containers}"| fzf ${FZF_OPTS} --header="Select a container:" | awk '{print $1}')
           str_opts="${str_opts} -c ${container}"
        fi

        log_info "kubectl ${str_opts} ${args}"
        kubectl ${str_opts} ${args}
    else
        log_warn "No resource found!"
    fi
}

# Main
function main {
    if [[ $# -ge 2 ]]; then
        _kcf_cmd "$@"
        exit $?
    else
        log_error "At least 2 arguments are required!"
    fi

    print_usage
    exit 1
}

main "$@"
