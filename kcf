#!/usr/bin/env bash

set -eou pipefail


readonly SCRIPT_NAME="$(basename "$0")"
readonly -a SUPPORTED_CMD=("exec" "log" "logs" "describe" "delete")
readonly -a SUPPORTED_CMD_CONTAINER=("exec" "log" "logs")

function print_usage {
    echo
    echo "${SCRIPT_NAME} wraps certain kubectl commands with fzf. It means that it allows you to select a resource corresponding to the specified type and perform the given command on it."
    echo
    echo "${SCRIPT_NAME} uses the same commands, resource types and options as kubectl."
    echo
    echo "Usage: ${SCRIPT_NAME} <CMD> <TYPE> <OPTION1>...<OPTIONX>"
    echo
    echo -e "CMD:       exec, log(s), describe and delete."
    echo -e "TYPE:      all kubectl resource types supported by the above commands."
    echo -e "OPTIONS:   all kubectl options normally used with the above commands & types."
    echo
    echo "Examples:"
    echo -e "- Describe a pod in a given namespace:"
    echo -e "  kcf describe pod -n istio-system"
    echo
    echo -e "- Execute a command shell in a container within a pod:"
    echo -e "  kcf exec pod -n dsf-offer-catalog-orchestrator -- ls -la"
    echo
    echo -e "- Execute a interactive shell in a container within a pod:"
    echo -e "  kcf exec pod -n dsf-offer-catalog-orchestrator -it -- bash"
    echo
    echo -e "- Watch logs of a container within a pod in a given namespace:"
    echo -e "  kcf logs pod -n istio-system -f"

}

function log {
    local readonly level="$1"
    local readonly message="$2"
    local readonly timestamp=$(date +"%Y-%m-%d %H:%M:%S")
    local color=""
    local reset_color="$(tput sgr0)"

    if [[ "${level}" == "INFO" ]]; then
        color="$(tput setaf 2)"
    elif [[ "${level}" == "WARN" ]]; then
        color="$(tput setaf 3)"
    elif [[ "${level}" == "ERROR" ]]; then
        color="$(tput setaf 1)"
    fi

    >&2 echo -e "${color}${timestamp} [${level}] [$SCRIPT_NAME] ${message}${reset_color}"
}

function log_info {
    local readonly message="$1"
    log "INFO" "$message"
}

function log_warn {
    local readonly message="$1"
    log "WARN" "$message"
}

function log_error {
    local readonly message="$1"
    log "ERROR" "$message"
}

function assert_not_empty {
    local readonly arg_name="$1"
    local readonly arg_value="$2"

    if [[ -z "$arg_value" ]]; then
        log_error "The value for '$arg_name' cannot be empty"
        print_usage
        exit 1
    fi
}

function assert_error {
    local readonly ret=$1
    loca""l readonly msg="$2"

    if [ ${ret} -ne 0 ]
    then
        if [ "${msg}" != "" ]
        then
            log_err "${msg}"
        fi
        exit 1
    fi
}

# Check if an item is in the array
# Params:
#   $1: item
#   $2: array
# Return
#   1 if yes, 0 otherwise
#
# Examples:
#   array_contains "B" ("A", "B", "C")
#   Returns: 1
function array_contains {
    local -r item="$1"
    shift
    local -ra arr=("$@")

    local it
    for it in "${arr[@]}"; do
        if [[ "$it" == "$item" ]]; then
            return 0
        fi
    done

    return 1
}

function array_split {
    local -r separator="$1"
    local -r str="$2"
    local -a arr=()

    IFS="$separator" read -a arr <<<"$str"

    echo ${arr[*]}
}

function str_remove_multiple_spaces {
    local -r str="$1"

    echo -e "${str}" | sed 's/  */ /g'
}

function _kcf_get_pod_containers {
    local -r podname="$1"
    local -r opts="$2"

    local str_opts=`str_remove_multiple_spaces "get pod/${podname} ${opts} -o jsonpath='{.spec.containers[*].name}'"`
    # Dont know why there are quote un the returned string.
    # So need to remove them and replace space by newline \n
    # to show correctly the list with fzf
    kubectl ${str_opts} | sed "s/\'//g" | tr " " "\n"
}

function _kcf_cmd {
    local readonly cmd="$1"
    local readonly type="$2"
    shift 2

    local ns=""
    local get_opts=""
    local cmd_opts=""
    local args=""

    while [[ $# > 0 ]]; do
        local key="$1"

        case "$key" in
            -n|--namespace)
                get_opts="${get_opts} -n $2"
                cmd_opts="${cmd_opts} -n $2"
                shift 2
                ;;
            --)
                args="${args} $@"
                shift $#
                ;;
            *)
                cmd_opts="${cmd_opts} ${key}"
                shift
                ;;
            esac
        done

    #echo "get_opts $get_opts"
    #echo "cmd_opts $cmd_opts"
    #echo "args $args"

    # Check cmd
    if ! array_contains "${cmd}" "${SUPPORTED_CMD[@]}"; then
        log_error "${cmd} not supported"
        return 1
    fi

    local resources=$(kubectl get ${type} --no-headers ${get_opts})

    # Split string containing all resources to array with '\n' as delimiter
    local SAVEIFS=${IFS}
    local IFS=$'\n'
    local readonly arr_resources=($resources)
    IFS=${SAVEIFS}

    if [[ ${#arr_resources[@]} -gt 0 ]]; then
        #echo "${resources}" | fzf | awk '{print $1}' | xargs -o -I % kubectl ${cmd} ${type}/% ${ns} ${args}
        resource=$(echo "${resources}" | fzf | awk '{print $1}')

        # Clean spaces in case of namespace not specified
        local str_opts=$(str_remove_multiple_spaces "${cmd} ${type}/${resource} ${cmd_opts}")
        ## Check if cmd needs to specify container
        if array_contains "${cmd}" "${SUPPORTED_CMD_CONTAINER[@]}"; then
           local container=$(_kcf_get_pod_containers "${resource}" "${get_opts}" | fzf | awk '{print $1}')
           #_kcf_get_pod_containers "${resource}" "${get_opts}"
           str_opts="${str_opts} -c ${container}"
        fi

        log_info "kubectl ${str_opts} ${args}"
        kubectl ${str_opts} ${args}
    else
        log_warn "No resource found!"
    fi
}

function main {
    if [[ $# -ge 2 ]]; then
        _kcf_cmd "$@"
        exit $?
    else
        log_error "At least 3 arguments are required!"
    fi

    print_usage
    exit 1
}

main "$@"
